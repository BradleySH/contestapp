"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.configureAsync = configureAsync;
exports.getEmbeddedManifestPath = getEmbeddedManifestPath;
exports.shouldEmbedAssetsForExpoUpdates = shouldEmbedAssetsForExpoUpdates;
exports.getIOSPaths = getIOSPaths;

function _config() {
  const data = require("@expo/config");

  _config = function () {
    return data;
  };

  return data;
}

function _configPlugins() {
  const data = require("@expo/config-plugins");

  _configPlugins = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _semver() {
  const data = _interopRequireDefault(require("semver"));

  _semver = function () {
    return data;
  };

  return data;
}

function _internal() {
  const data = require("./internal");

  _internal = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function configureAsync(config) {
  await _maybeWriteArtifactsToDiskAsync(config);
  await _maybeConfigureExpoKitEmbeddedAssetsAsync(config);
  await _maybeConfigureExpoUpdatesEmbeddedAssetsAsync(config);
}

function getEmbeddedManifestPath(platform, projectRoot, exp) {
  if (platform === 'ios') {
    return exp.ios && exp.ios.publishManifestPath ? exp.ios.publishManifestPath : _getDefaultEmbeddedManifestPath(platform, projectRoot, exp);
  } else if (platform === 'android') {
    return exp.android && exp.android.publishManifestPath ? exp.android.publishManifestPath : _getDefaultEmbeddedManifestPath(platform, projectRoot, exp);
  }

  return _getDefaultEmbeddedManifestPath(platform, projectRoot, exp);
}

function _getDefaultEmbeddedManifestPath(platform, projectRoot, exp) {
  return _path().default.join(_getDefaultEmbeddedAssetDir(platform, projectRoot, exp), 'app.manifest');
}

function _getDefaultEmbeddedBundlePath(platform, projectRoot, exp) {
  return _path().default.join(_getDefaultEmbeddedAssetDir(platform, projectRoot, exp), 'app.bundle');
}

function _getDefaultEmbeddedAssetDir(platform, projectRoot, exp) {
  if (platform === 'ios') {
    const {
      iosSupportingDirectory
    } = getIOSPaths(projectRoot);
    return iosSupportingDirectory;
  } else if (platform === 'android') {
    return _path().default.join(projectRoot, 'android', 'app', 'src', 'main', 'assets');
  } else {
    throw new Error('Embedding assets is not supported for platform ' + platform);
  }
}

function shouldEmbedAssetsForExpoUpdates(projectRoot, exp, pkg, target) {
  var _pkg$dependencies;

  if (!((_pkg$dependencies = pkg.dependencies) !== null && _pkg$dependencies !== void 0 && _pkg$dependencies['expo-updates']) || target !== 'bare') {
    return false;
  } // semver.coerce can return null


  const expoUpdatesVersion = _semver().default.coerce(pkg.dependencies['expo-updates']); // expo-updates 0.1.x relies on expo-cli automatically embedding the manifest and bundle


  if (expoUpdatesVersion && _semver().default.satisfies(expoUpdatesVersion, '~0.1.0')) {
    return true;
  } // We also want to support developers who had expo-updates 0.1.x and upgraded but still rely on
  // expo-cli's automatic embedding. If the files already exist we can assume we need to update them


  if (_fsExtra().default.existsSync(_getDefaultEmbeddedBundlePath('android', projectRoot, exp)) || _fsExtra().default.existsSync(_getDefaultEmbeddedManifestPath('android', projectRoot, exp)) || _fsExtra().default.existsSync(_getDefaultEmbeddedBundlePath('ios', projectRoot, exp)) || _fsExtra().default.existsSync(_getDefaultEmbeddedManifestPath('ios', projectRoot, exp))) {
    return true;
  }

  return false;
}

async function _maybeWriteArtifactsToDiskAsync(config) {
  var _exp$android, _exp$android2, _exp$ios, _exp$ios2;

  const {
    projectRoot,
    pkg,
    exp,
    iosManifest,
    iosBundle,
    androidManifest,
    androidBundle,
    target
  } = config;
  let androidBundlePath;
  let androidManifestPath;
  let iosBundlePath;
  let iosManifestPath;

  if (shouldEmbedAssetsForExpoUpdates(projectRoot, exp, pkg, target)) {
    const defaultAndroidDir = _getDefaultEmbeddedAssetDir('android', projectRoot, exp);

    const defaultIosDir = _getDefaultEmbeddedAssetDir('ios', projectRoot, exp);

    await _fsExtra().default.ensureDir(defaultIosDir);
    await _fsExtra().default.ensureDir(defaultAndroidDir);
    androidBundlePath = _getDefaultEmbeddedBundlePath('android', projectRoot, exp);
    androidManifestPath = _getDefaultEmbeddedManifestPath('android', projectRoot, exp);
    iosBundlePath = _getDefaultEmbeddedBundlePath('ios', projectRoot, exp);
    iosManifestPath = _getDefaultEmbeddedManifestPath('ios', projectRoot, exp);

    if (!_fsExtra().default.existsSync(iosBundlePath) || !_fsExtra().default.existsSync(iosManifestPath)) {
      _internal().Logger.global.warn('Creating app.manifest and app.bundle inside of your ios/<project>/Supporting directory.\nBe sure to add these files to your Xcode project. More info at https://expo.fyi/embedded-assets');
    }
  } // allow custom overrides


  if ((_exp$android = exp.android) !== null && _exp$android !== void 0 && _exp$android.publishBundlePath) {
    androidBundlePath = exp.android.publishBundlePath;
  }

  if ((_exp$android2 = exp.android) !== null && _exp$android2 !== void 0 && _exp$android2.publishManifestPath) {
    androidManifestPath = exp.android.publishManifestPath;
  }

  if ((_exp$ios = exp.ios) !== null && _exp$ios !== void 0 && _exp$ios.publishBundlePath) {
    iosBundlePath = exp.ios.publishBundlePath;
  }

  if ((_exp$ios2 = exp.ios) !== null && _exp$ios2 !== void 0 && _exp$ios2.publishManifestPath) {
    iosManifestPath = exp.ios.publishManifestPath;
  }

  if (androidBundlePath) {
    await (0, _internal().writeArtifactSafelyAsync)(projectRoot, 'android.publishBundlePath', androidBundlePath, androidBundle);
  }

  if (androidManifestPath) {
    await (0, _internal().writeArtifactSafelyAsync)(projectRoot, 'android.publishManifestPath', androidManifestPath, JSON.stringify(androidManifest));
  }

  if (iosBundlePath) {
    await (0, _internal().writeArtifactSafelyAsync)(projectRoot, 'ios.publishBundlePath', iosBundlePath, iosBundle);
  }

  if (iosManifestPath) {
    await (0, _internal().writeArtifactSafelyAsync)(projectRoot, 'ios.publishManifestPath', iosManifestPath, JSON.stringify(iosManifest));
  }
}

async function _maybeConfigureExpoKitEmbeddedAssetsAsync(config) {
  const {
    projectRoot,
    exp,
    releaseChannel,
    androidManifestUrl,
    androidManifest
  } = config;

  const context = _internal().StandaloneContext.createUserContext(projectRoot, exp);

  const {
    supportingDirectory
  } = _internal().IosWorkspace.getPaths(context); // iOS ExpoKit


  if (releaseChannel && _fsExtra().default.existsSync(_path().default.join(supportingDirectory, 'EXShell.plist'))) {
    // This is an ExpoKit app, set properties in EXShell.plist
    await _internal().IosPlist.modifyAsync(supportingDirectory, 'EXShell', shellPlist => {
      shellPlist.releaseChannel = releaseChannel;
      return shellPlist;
    });
  } // Android ExpoKit


  const constantsPath = _path().default.join(projectRoot, 'android', 'app', 'src', 'main', 'java', 'host', 'exp', 'exponent', 'generated', 'AppConstants.java');

  if (_fsExtra().default.existsSync(constantsPath)) {
    // This is an ExpoKit app
    // We need to add EmbeddedResponse instances on Android to tell the runtime
    // that the shell app manifest and bundle is packaged.
    await _internal().ExponentTools.deleteLinesInFileAsync(`START EMBEDDED RESPONSES`, `END EMBEDDED RESPONSES`, constantsPath);
    await _internal().ExponentTools.regexFileAsync('// ADD EMBEDDED RESPONSES HERE', `
      // ADD EMBEDDED RESPONSES HERE
      // START EMBEDDED RESPONSES
      embeddedResponses.add(new Constants.EmbeddedResponse("${androidManifestUrl}", "assets://shell-app-manifest.json", "application/json"));
      embeddedResponses.add(new Constants.EmbeddedResponse("${androidManifest.bundleUrl}", "assets://shell-app.bundle", "application/javascript"));
      // END EMBEDDED RESPONSES`, constantsPath);

    if (releaseChannel) {
      await _internal().ExponentTools.regexFileAsync(/RELEASE_CHANNEL = "[^"]*"/, `RELEASE_CHANNEL = "${releaseChannel}"`, constantsPath);
    }
  }
}

async function _maybeConfigureExpoUpdatesEmbeddedAssetsAsync(config) {
  var _config$pkg$dependenc;

  if (!((_config$pkg$dependenc = config.pkg.dependencies) !== null && _config$pkg$dependenc !== void 0 && _config$pkg$dependenc['expo-updates']) || config.target === 'managed') {
    return;
  }

  let isLikelyFirstPublish = false;
  const {
    projectRoot,
    exp,
    releaseChannel,
    iosManifestUrl,
    androidManifestUrl
  } = config;
  const {
    iosSupportingDirectory: supportingDirectory
  } = getIOSPaths(projectRoot); // iOS expo-updates

  if (_fsExtra().default.existsSync(_path().default.join(supportingDirectory, 'Expo.plist'))) {
    // This is an app with expo-updates installed, set properties in Expo.plist
    await _internal().IosPlist.modifyAsync(supportingDirectory, 'Expo', configPlist => {
      if (configPlist.EXUpdatesURL === 'YOUR-APP-URL-HERE') {
        isLikelyFirstPublish = true;
      }

      configPlist.EXUpdatesURL = iosManifestUrl;
      configPlist.EXUpdatesSDKVersion = exp.sdkVersion;

      if (releaseChannel) {
        configPlist.EXUpdatesReleaseChannel = releaseChannel;
      }

      return configPlist;
    });
    await _internal().IosPlist.cleanBackupAsync(supportingDirectory, 'Expo', false);
  } // Android expo-updates


  const androidManifestXmlPath = _path().default.join(projectRoot, 'android', 'app', 'src', 'main', 'AndroidManifest.xml');

  const androidManifestXmlFile = _fsExtra().default.readFileSync(androidManifestXmlPath, 'utf8');

  const expoUpdateUrlRegex = /<meta-data[^>]+"expo.modules.updates.EXPO_UPDATE_URL"[^>]+\/>/;
  const expoSdkVersionRegex = /<meta-data[^>]+"expo.modules.updates.EXPO_SDK_VERSION"[^>]+\/>/;
  const expoReleaseChannelRegex = /<meta-data[^>]+"expo.modules.updates.EXPO_RELEASE_CHANNEL"[^>]+\/>/;
  const expoUpdateUrlTag = `<meta-data android:name="expo.modules.updates.EXPO_UPDATE_URL" android:value="${androidManifestUrl}" />`;
  const expoSdkVersionTag = `<meta-data android:name="expo.modules.updates.EXPO_SDK_VERSION" android:value="${exp.sdkVersion}" />`;
  const expoReleaseChannelTag = `<meta-data android:name="expo.modules.updates.EXPO_RELEASE_CHANNEL" android:value="${releaseChannel}" />`;
  const tagsToInsert = [];

  if (androidManifestXmlFile.search(expoUpdateUrlRegex) < 0) {
    tagsToInsert.push(expoUpdateUrlTag);
  }

  if (androidManifestXmlFile.search(expoSdkVersionRegex) < 0) {
    tagsToInsert.push(expoSdkVersionTag);
  }

  if (releaseChannel && androidManifestXmlFile.search(expoReleaseChannelRegex) < 0) {
    tagsToInsert.push(expoReleaseChannelTag);
  }

  if (tagsToInsert.length) {
    // try to insert the meta-data tags that aren't found
    await _internal().ExponentTools.regexFileAsync(/<activity\s+android:name=".MainActivity"/, `${tagsToInsert.join('\n      ')}

  <activity
    android:name=".MainActivity"`, androidManifestXmlPath);
  }

  await _internal().ExponentTools.regexFileAsync(expoUpdateUrlRegex, expoUpdateUrlTag, androidManifestXmlPath);
  await _internal().ExponentTools.regexFileAsync(expoSdkVersionRegex, expoSdkVersionTag, androidManifestXmlPath);

  if (releaseChannel) {
    await _internal().ExponentTools.regexFileAsync(expoReleaseChannelRegex, expoReleaseChannelTag, androidManifestXmlPath);
  }

  if (isLikelyFirstPublish) {
    _internal().Logger.global.warn('ðŸš€ It looks like this your first publish for this project! ' + "We've automatically set some configuration values in Expo.plist and AndroidManifest.xml. " + "You'll need to make a new build with these changes before you can download the update " + 'you just published.');
  }
}
/** The code below here is duplicated from expo-cli currently **/
// TODO: it's silly and kind of fragile that we look at app config to determine
// the ios project paths. Overall this function needs to be revamped, just a
// placeholder for now! Make this more robust when we support applying config
// at any time (currently it's only applied on eject).


function getIOSPaths(projectRoot) {
  const {
    exp
  } = (0, _config().getConfig)(projectRoot, {
    skipSDKVersionRequirement: true
  });
  const projectName = exp.name;

  if (!projectName) {
    throw new Error('Your project needs a name in app.json/app.config.js.');
  }

  const iosProjectDirectory = _path().default.join(projectRoot, 'ios', _configPlugins().IOSConfig.XcodeUtils.sanitizedName(projectName));

  const iosSupportingDirectory = _path().default.join(projectRoot, 'ios', _configPlugins().IOSConfig.XcodeUtils.sanitizedName(projectName), 'Supporting');

  const iconPath = _path().default.join(iosProjectDirectory, 'Assets.xcassets', 'AppIcon.appiconset');

  return {
    projectName,
    iosProjectDirectory,
    iosSupportingDirectory,
    iconPath
  };
}
//# sourceMappingURL=EmbeddedAssets.js.map