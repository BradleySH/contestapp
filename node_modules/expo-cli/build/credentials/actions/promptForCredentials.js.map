{"version":3,"sources":["../../../src/credentials/actions/promptForCredentials.ts"],"names":["EXPERT_PROMPT","log","warn","askForUserProvided","schema","willUserProvideCredentialsType","name","getCredentialsFromUser","credentialType","results","field","required","askQuestionAndProcessAnswer","answer","type","message","choices","value","definition","questionObject","buildQuestionObject","input","processAnswer","question","filter","produceAbsolutePath","validate","validators","existingFile","nonEmptyInput","base64Encode","fs","readFile","filePath","untildified","trim","path","isAbsolute","resolve"],"mappings":";;;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;AAyBA,MAAMA,aAAa,GAAG,qBAAK,MACzBC,eAAIC,IAAJ,CAAU;;;;;;;CAAV,CADoB,CAAtB;;AAWO,eAAeC,kBAAf,CACLC,MADK,EAEc;AACnB,MAAI,MAAMC,8BAA8B,CAACD,MAAM,CAACE,IAAR,CAAxC,EAAuD;AACrDN,IAAAA,aAAa;AACb,WAAO,MAAMO,sBAAsB,CAACH,MAAD,CAAnC;AACD;;AACD,SAAO,IAAP;AACD;;AAEM,eAAeG,sBAAf,CACLC,cADK,EAEc;AACnB,QAAMC,OAAgB,GAAG,EAAzB;;AACA,OAAK,MAAMC,KAAX,IAAoBF,cAAc,CAACG,QAAnC,EAA6C;AAC3CF,IAAAA,OAAO,CAACC,KAAD,CAAP,GAAiB,MAAME,2BAA2B,CAAC,oBAAIJ,cAAJ,EAAqB,aAAYE,KAAM,EAAvC,CAAD,CAAlD;AACD;;AACD,SAAOD,OAAP;AACD;;AAED,eAAeJ,8BAAf,CAA8CC,IAA9C,EAA4D;AAC1D,QAAM;AAAEO,IAAAA;AAAF,MAAa,MAAM,uBAAO;AAC9BC,IAAAA,IAAI,EAAE,MADwB;AAE9BR,IAAAA,IAAI,EAAE,QAFwB;AAG9BS,IAAAA,OAAO,EAAG,6BAA4BT,IAAK,GAHb;AAI9BU,IAAAA,OAAO,EAAE,CACP;AAAEV,MAAAA,IAAI,EAAE,6BAAR;AAAuCW,MAAAA,KAAK,EAAE;AAA9C,KADO,EAEP;AAAEX,MAAAA,IAAI,EAAE,8BAAR;AAAwCW,MAAAA,KAAK,EAAE;AAA/C,KAFO;AAJqB,GAAP,CAAzB;AASA,SAAOJ,MAAP;AACD;;AAED,eAAeD,2BAAf,CAA2CM,UAA3C,EAAkF;AAChF,QAAMC,cAAc,GAAGC,mBAAmB,CAACF,UAAD,CAA1C;AACA,QAAM;AAAEG,IAAAA;AAAF,MAAY,MAAM,uBAAOF,cAAP,CAAxB;AACA,SAAO,MAAMG,aAAa,CAACJ,UAAD,EAAaG,KAAb,CAA1B;AACD;;AAED,SAASD,mBAAT,CAA6B;AAAEN,EAAAA,IAAF;AAAQS,EAAAA;AAAR,CAA7B,EAA2E;AACzE,UAAQT,IAAR;AACE,SAAK,QAAL;AACE,aAAO;AACLA,QAAAA,IAAI,EAAE,OADD;AAELR,QAAAA,IAAI,EAAE,OAFD;AAGLS,QAAAA,OAAO,EAAEQ;AAHJ,OAAP;;AAKF,SAAK,MAAL;AACE,aAAO;AACLT,QAAAA,IAAI,EAAE,OADD;AAELR,QAAAA,IAAI,EAAE,OAFD;AAGLS,QAAAA,OAAO,EAAEQ,QAHJ;AAILC,QAAAA,MAAM,EAAEC,mBAJH;AAKLC,QAAAA,QAAQ,EAAEC,UAAU,GAACC;AALhB,OAAP;;AAOF,SAAK,UAAL;AACE,aAAO;AACLd,QAAAA,IAAI,EAAE,UADD;AAELR,QAAAA,IAAI,EAAE,OAFD;AAGLS,QAAAA,OAAO,EAAEQ,QAHJ;AAILG,QAAAA,QAAQ,EAAEC,UAAU,GAACE;AAJhB,OAAP;AAhBJ;AAuBD;;AAED,eAAeP,aAAf,CAA6B;AAAER,EAAAA,IAAF;AAAQgB,EAAAA;AAAR,CAA7B,EAA+DT,KAA/D,EAA+F;AAC7F,MAAIP,IAAI,KAAK,MAAb,EAAqB;AACnB,WAAOiB,mBAAGC,QAAH,CAAYX,KAAZ,EAAmBS,YAAY,GAAG,QAAH,GAAc,MAA7C,CAAP;AACD,GAFD,MAEO;AACL,WAAOT,KAAP;AACD;AACF;;AAED,SAASI,mBAAT,CAA6BQ,QAA7B,EAAuD;AACrD,QAAMC,WAAW,GAAG,0BAAUD,QAAQ,CAACE,IAAT,EAAV,CAApB;AACA,SAAO,CAACC,gBAAKC,UAAL,CAAgBH,WAAhB,CAAD,GAAgCE,gBAAKE,OAAL,CAAaJ,WAAb,CAAhC,GAA4DA,WAAnE;AACD","sourcesContent":["import path from 'path';\nimport untildify from 'untildify';\nimport fs from 'fs-extra';\nimport get from 'lodash/get';\nimport once from 'lodash/once';\n\nimport prompt, { Question as PromptQuestion } from '../../prompt';\nimport log from '../../log';\nimport * as validators from '../../validators';\n\nexport type Question = {\n  question: string;\n  type: 'file' | 'string' | 'password';\n  base64Encode?: boolean;\n};\n\ntype Results = {\n  [key: string]: string | undefined;\n};\n\nexport type CredentialSchema<T> = {\n  id: string;\n  canReuse?: boolean;\n  dependsOn?: string;\n  name: string;\n  required: Array<string>;\n  questions?: {\n    [key: string]: Question;\n  };\n  deprecated?: boolean;\n  migrationDocs?: string;\n};\n\nconst EXPERT_PROMPT = once(() =>\n  log.warn(`\nWARNING! In this mode, we won't be able to make sure that your credentials are valid.\nPlease double check that you're uploading valid files for your app otherwise you may encounter strange errors!\n\nWhen building for IOS make sure you've created your App ID on the Apple Developer Portal, that your App ID\nis in app.json as \\`bundleIdentifier\\`, and that the provisioning profile you\nupload matches that Team ID and App ID.\n`)\n);\n\nexport async function askForUserProvided<T extends Results>(\n  schema: CredentialSchema<T>\n): Promise<T | null> {\n  if (await willUserProvideCredentialsType(schema.name)) {\n    EXPERT_PROMPT();\n    return await getCredentialsFromUser(schema);\n  }\n  return null;\n}\n\nexport async function getCredentialsFromUser<T extends Results>(\n  credentialType: CredentialSchema<T>\n): Promise<T | null> {\n  const results: Results = {};\n  for (const field of credentialType.required) {\n    results[field] = await askQuestionAndProcessAnswer(get(credentialType, `questions.${field}`));\n  }\n  return results as T;\n}\n\nasync function willUserProvideCredentialsType(name: string) {\n  const { answer } = await prompt({\n    type: 'list',\n    name: 'answer',\n    message: `Will you provide your own ${name}?`,\n    choices: [\n      { name: 'Let Expo handle the process', value: false },\n      { name: 'I want to upload my own file', value: true },\n    ],\n  });\n  return answer;\n}\n\nasync function askQuestionAndProcessAnswer(definition: Question): Promise<string> {\n  const questionObject = buildQuestionObject(definition);\n  const { input } = await prompt(questionObject);\n  return await processAnswer(definition, input);\n}\n\nfunction buildQuestionObject({ type, question }: Question): PromptQuestion {\n  switch (type) {\n    case 'string':\n      return {\n        type: 'input',\n        name: 'input',\n        message: question,\n      };\n    case 'file':\n      return {\n        type: 'input',\n        name: 'input',\n        message: question,\n        filter: produceAbsolutePath,\n        validate: validators.existingFile,\n      } as PromptQuestion;\n    case 'password':\n      return {\n        type: 'password',\n        name: 'input',\n        message: question,\n        validate: validators.nonEmptyInput,\n      };\n  }\n}\n\nasync function processAnswer({ type, base64Encode }: Question, input: string): Promise<string> {\n  if (type === 'file') {\n    return fs.readFile(input, base64Encode ? 'base64' : 'utf8');\n  } else {\n    return input;\n  }\n}\n\nfunction produceAbsolutePath(filePath: string): string {\n  const untildified = untildify(filePath.trim());\n  return !path.isAbsolute(untildified) ? path.resolve(untildified) : untildified;\n}\n"],"file":"promptForCredentials.js"}